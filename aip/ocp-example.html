<!DOCTYPE html>
<html>
<head>
<title>The MSD Book :: OCP Example</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="what-ocp-actually-says-short">What OCP <em>actually</em> says (short)</h1>
<p>
	<img src="msd-book-front.png" 
    alt="The MSD Book" width="200" style="float: left; margin: 0 1rem 1rem 0;"/>
	
	<strong>Open for extension, closed for modification.</strong>
Make it easy to add new behavior without changing the existing, tested code that uses that behavior. Practically, you design stable abstraction points so new features are added by adding new modules (or classes) that implement those abstractions — not by editing existing business logic.</p>
<h1 id="why-ocp-matters-in-modern-software">Why OCP matters in modern software</h1>
<ul>
<li><strong>Reduces risk:</strong> avoids repeatedly changing trusted code paths (fewer regressions).</li>
<li><strong>Enables safe evolution:</strong> new features (strategies, providers, formats) plug in without touching core logic.</li>
<li><strong>Improves testability:</strong> you can unit-test new behaviors in isolation.</li>
<li><strong>Supports modular teams &amp; CI/CD:</strong> teams add modules independently.</li>
<li><strong>Aids runtime extensibility:</strong> plugin systems, feature flags, dynamic registration.</li>
</ul>
<h1 id="when-to-apply-ocp-where-it-helps-most">When to apply OCP (where it helps most)</h1>
<ul>
<li><strong>Third-party integrations</strong> (payment gateways, notification providers, storage backends).</li>
<li><strong>Format/strategy families</strong> (serialization formats, caching strategies, compression algorithms).</li>
<li><strong>Feature toggles &amp; experiment variants</strong> (A/B strategies).</li>
<li><strong>Core domain policies</strong> that are expected to change frequently (discount rules, tax rules).</li>
<li><strong>Systems requiring runtime swaps</strong> (different behavior per customer/tenant).</li>
</ul>
<h1 id="when-not-to-over-apply-ocp">When <em>not</em> to over-apply OCP</h1>
<ul>
<li>For trivial code that will never vary — excessive abstraction adds needless indirection.</li>
<li>When early YAGNI abstractions complicate the codebase — prefer refactoring when need arises, but design hooks where low-cost.</li>
</ul>
<h1 id="design-patterns-that-implement-ocp">Design patterns that implement OCP</h1>
<ul>
<li>Strategy / Policy objects</li>
<li>Plugin registries (discovery &amp; registration)</li>
<li>Factory + registration map</li>
<li>Adapter / Bridge (when wrapping unstable third-party APIs)</li>
<li>Composition-over-inheritance: favor composing small, testable behaviors.</li>
</ul>
<hr>
<h1 id="concrete-example--real-module-and-an-ocp-focused-refactor">Concrete example — real module and an OCP-focused refactor</h1>
<p><strong>Scenario:</strong> an <code>EmailNotificationService</code> that currently handles multiple notification channels (email, SMS, push) in one class with <code>if/else</code> logic. We want to make adding new channels (e.g., WhatsApp, Slack) possible without changing the service.</p>
<p>I'll use <strong>TypeScript</strong> for clarity, but the ideas map directly to Java/Kotlin/C# etc.</p>
<h2 id="before-ocp-violation--monolith-switchif-logic">Before (OCP violation — monolith <code>switch</code>/<code>if</code> logic)</h2>
<pre class="hljs"><code><div><span class="hljs-comment">// before/NotificationService.ts</span>
<span class="hljs-keyword">type</span> Channel = <span class="hljs-string">'email'</span> | <span class="hljs-string">'sms'</span> | <span class="hljs-string">'push'</span>;

<span class="hljs-keyword">class</span> NotificationService {
  send(channel: Channel, to: <span class="hljs-built_in">string</span>, message: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">if</span> (channel === <span class="hljs-string">'email'</span>) {
      <span class="hljs-comment">// compose email, use SMTP client</span>
      smtpClient.send({to, body: message});
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channel === <span class="hljs-string">'sms'</span>) {
      <span class="hljs-comment">// use SMS provider</span>
      smsProvider.sendSMS(to, message);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (channel === <span class="hljs-string">'push'</span>) {
      pushService.push(to, message);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'unsupported channel'</span>);
    }
  }
}
</div></code></pre>
<p>Problems:</p>
<ul>
<li>Adding a channel requires modifying <code>NotificationService</code> — a core class.</li>
<li>Tests for <code>NotificationService</code> become brittle.</li>
<li>Mixing high-level orchestration with low-level provider details.</li>
</ul>
<h2 id="after-ocp-compliant-define-an-abstraction-and-register-implementations">After (OCP-compliant): define an abstraction and register implementations</h2>
<h3 id="1-abstraction-interface">1) Abstraction (interface)</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// after/interfaces/Notifier.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Notifier {
  channelId(): <span class="hljs-built_in">string</span>;      <span class="hljs-comment">// e.g. 'email', 'sms', etc.</span>
  send(to: <span class="hljs-built_in">string</span>, message: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt;;
}
</div></code></pre>
<h3 id="2-concrete-implementations">2) Concrete implementations</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// after/notifiers/EmailNotifier.ts</span>
<span class="hljs-keyword">import</span> { Notifier } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/Notifier'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> EmailNotifier <span class="hljs-keyword">implements</span> Notifier {
  channelId() { <span class="hljs-keyword">return</span> <span class="hljs-string">'email'</span>; }
  <span class="hljs-keyword">async</span> send(to: <span class="hljs-built_in">string</span>, message: <span class="hljs-built_in">string</span>) {
    <span class="hljs-comment">// small wrapper around smtpClient</span>
    <span class="hljs-keyword">await</span> smtpClient.send({ to, body: message });
  }
}

<span class="hljs-comment">// after/notifiers/SmsNotifier.ts</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> SmsNotifier <span class="hljs-keyword">implements</span> Notifier {
  channelId() { <span class="hljs-keyword">return</span> <span class="hljs-string">'sms'</span>; }
  <span class="hljs-keyword">async</span> send(to: <span class="hljs-built_in">string</span>, message: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">await</span> smsProvider.sendSMS(to, message);
  }
}
</div></code></pre>
<h3 id="3-registry--factory">3) Registry / factory</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// after/registry/NotifierRegistry.ts</span>
<span class="hljs-keyword">import</span> { Notifier } <span class="hljs-keyword">from</span> <span class="hljs-string">'../interfaces/Notifier'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NotifierRegistry {
  <span class="hljs-keyword">private</span> map = <span class="hljs-keyword">new</span> Map&lt;<span class="hljs-built_in">string</span>, Notifier&gt;();

  register(notifier: Notifier) {
    <span class="hljs-keyword">this</span>.map.set(notifier.channelId(), notifier);
  }

  <span class="hljs-keyword">get</span>(channel: <span class="hljs-built_in">string</span>): Notifier {
    <span class="hljs-keyword">const</span> n = <span class="hljs-keyword">this</span>.map.get(channel);
    <span class="hljs-keyword">if</span> (!n) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`no notifier for <span class="hljs-subst">${channel}</span>`</span>);
    <span class="hljs-keyword">return</span> n;
  }
}
</div></code></pre>
<h3 id="4-high-level-service-closed-for-modification">4) High-level service (closed for modification)</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// after/NotificationService.ts</span>
<span class="hljs-keyword">import</span> { NotifierRegistry } <span class="hljs-keyword">from</span> <span class="hljs-string">'./registry/NotifierRegistry'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> NotificationService {
  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> registry: NotifierRegistry</span>) {}

  <span class="hljs-keyword">async</span> send(channel: <span class="hljs-built_in">string</span>, to: <span class="hljs-built_in">string</span>, message: <span class="hljs-built_in">string</span>) {
    <span class="hljs-keyword">const</span> notifier = <span class="hljs-keyword">this</span>.registry.get(channel);
    <span class="hljs-keyword">await</span> notifier.send(to, message);
  }
}
</div></code></pre>
<h3 id="5-wiring-di--app-bootstrap">5) Wiring (DI / app bootstrap)</h3>
<pre class="hljs"><code><div><span class="hljs-comment">// after/bootstrap.ts</span>
<span class="hljs-keyword">const</span> registry = <span class="hljs-keyword">new</span> NotifierRegistry();
registry.register(<span class="hljs-keyword">new</span> EmailNotifier());
registry.register(<span class="hljs-keyword">new</span> SmsNotifier());
<span class="hljs-comment">// later: registry.register(new SlackNotifier()) — no change to NotificationService</span>

<span class="hljs-keyword">const</span> service = <span class="hljs-keyword">new</span> NotificationService(registry);
</div></code></pre>
<h2 id="why-this-is-ocp-compliant">Why this is OCP-compliant</h2>
<ul>
<li><code>NotificationService</code> is <strong>closed</strong>: we never modify it to add channels.</li>
<li>The system is <strong>open</strong>: to add a new channel, implement <code>Notifier</code> and <code>register</code> it. No existing code needs changes.</li>
<li>Tests: you can unit-test each <code>Notifier</code>, and test <code>NotificationService</code> with a fake registry or stub notifier.</li>
</ul>
<h2 id="advanced-extension-patterns">Advanced extension patterns</h2>
<ul>
<li><strong>Auto-discovery:</strong> load notifier implementations by convention or through DI container modules — new notifiers discovered at startup from configuration.</li>
<li><strong>Feature flags:</strong> conditionally enable notifiers using config, again without modifying <code>NotificationService</code>.</li>
<li><strong>Versioned handlers:</strong> if channel behavior changes, provide versioned implementations and select them at runtime.</li>
</ul>
<hr>
<h1 id="practical-refactor-checklist-step-by-step">Practical refactor checklist (step-by-step)</h1>
<ol>
<li><strong>Identify variation points</strong> (areas with <code>switch</code>, <code>if/else</code>, duplicated branching).</li>
<li><strong>Extract an abstraction</strong> (interface/abstract class) representing the varying behavior. Keep the interface small and stable.</li>
<li><strong>Move concrete behavior</strong> into classes that implement the abstraction. Keep them focused and testable.</li>
<li><strong>Introduce an indirection layer</strong> (registry/factory/DI container) that selects the implementation.</li>
<li><strong>Refactor callers</strong> to depend on the abstraction, not concrete implementations.</li>
<li><strong>Write tests</strong> for each concrete implementation and for the orchestrator with fakes.</li>
<li><strong>Document the extension point</strong>: how to add new implementations and how to register them.</li>
<li><strong>Add runtime guards</strong>: when appropriate, fail-fast with clear errors if no implementation found.</li>
<li><strong>Monitor for over-abstraction</strong>: remove the indirection if it becomes unused or never extended.</li>
</ol>
<hr>
<h1 id="lint-style-checklist-for-code-reviews-ocp-focused">Lint-style checklist for code reviews (OCP-focused)</h1>
<p>Add this as a short checklist item in PR templates:</p>
<ul>
<li><input type="checkbox" id="checkbox0"><label for="checkbox0"></label><strong>No <code>if/else</code> or <code>switch</code> controlling different strategies</strong> based on a type string where adding new variants would require editing the file. (If present, should be a clear TODO to extract a strategy.)</li>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1"></label><strong>High-level modules depend on abstractions</strong>, not concrete implementations. (Look for interfaces or abstract types at boundaries.)</li>
<li><input type="checkbox" id="checkbox2"><label for="checkbox2"></label><strong>New behavior implemented by adding new classes/modules</strong>, not by modifying core orchestration code. (Confirm via PR diff.)</li>
<li><input type="checkbox" id="checkbox3"><label for="checkbox3"></label><strong>Abstraction is intentionally small and stable</strong> (single responsibility, minimal method surface).</li>
<li><input type="checkbox" id="checkbox4"><label for="checkbox4"></label><strong>Concrete implementations are single-purpose</strong> and unit-tested independently.</li>
<li><input type="checkbox" id="checkbox5"><label for="checkbox5"></label><strong>Factory/registry/DI usage is used to select implementations</strong>; registration code is confined to bootstrap or plugin modules.</li>
<li><input type="checkbox" id="checkbox6"><label for="checkbox6"></label><strong>No duplicated branching logic</strong> across files: duplicated conditionals likely signal a missing abstraction.</li>
<li><input type="checkbox" id="checkbox7"><label for="checkbox7"></label><strong>Breaking changes avoided</strong>: check whether adding new implementations requires changing public API signatures or types — if yes, consider adding extension hooks instead.</li>
<li><input type="checkbox" id="checkbox8"><label for="checkbox8"></label><strong>Documentation present</strong>: brief note on how to add/enable a new implementation.</li>
<li><input type="checkbox" id="checkbox9"><label for="checkbox9"></label><strong>Performance &amp; safety checks</strong>: ensure abstraction indirection doesn’t add unacceptable overhead in hot paths; add caching or compile-time wiring for critical code paths.</li>
<li><input type="checkbox" id="checkbox10"><label for="checkbox10"></label><strong>Security/validation left at the right level</strong>: concrete implementations handle provider-specific validation; orchestrator handles stable invariants.</li>
<li><input type="checkbox" id="checkbox11"><label for="checkbox11"></label><strong>Feature toggles and config-driven selection</strong> are supported where runtime swaps are required.</li>
</ul>
<hr>
<h1 id="common-anti-patterns--pitfalls">Common anti-patterns &amp; pitfalls</h1>
<ul>
<li><strong>Premature abstraction</strong> — abstracting before there's a real need. Keep code readable; prefer refactor when multiple variants appear.</li>
<li><strong>Fat interfaces</strong> — large interfaces that force implementations to implement irrelevant methods. Prefer small, cohesive interfaces.</li>
<li><strong>Leaky abstractions</strong> — forcing callers to know implementation details (violates encapsulation).</li>
<li><strong>Hidden global registration</strong> — implicit plugin registration that’s hard to trace; prefer explicit registration in bootstrap or configuration.</li>
<li><strong>Overhead in hot paths</strong> — micro-optimization: for very hot loops, evaluate whether indirection hurts latency; consider compile-time wiring or inlining.</li>
</ul>
<hr>
<h1 id="quick-rules-of-thumb-for-choosing-granularity">Quick rules-of-thumb for choosing granularity</h1>
<ul>
<li>If behavior varies per <em>customer/tenant/provider</em> → abstraction.</li>
<li>If variation is only a single flag toggling behavior → consider simple conditional with a config flag (no abstraction).</li>
<li>If you foresee 2+ variants or open-ended future variants → extract an interface.</li>
</ul>
<hr>
<h1 id="short-example-adding-a-new-channel-whatsapp--what-changes">Short example: adding a new channel (WhatsApp) — what changes?</h1>
<p><strong>Before refactor:</strong> edit <code>NotificationService</code> and add another <code>else if</code>.
<strong>After refactor:</strong> create <code>WhatsAppNotifier implements Notifier</code> and <code>registry.register(new WhatsAppNotifier())</code>. No changes to <code>NotificationService</code>.</p>
<hr>
<p><strong>NOTE:</strong> This page is generated with assistance from AI tools.</p>

</body>
</html>
