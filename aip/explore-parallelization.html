<!DOCTYPE html>
<html>
<head>
<title>The MSD Book :: Explore Parallelization</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="recognize--exploit-parallelism-short-guide--c-examples">Recognize &amp; exploit parallelism (short guide + C# examples)</h1>
<p>
    <img src="msd-book-front.png" 
    alt="The MSD Book" width="200" style="float: left; margin: 0 1rem 1rem 0;"/>
    Parallelism comes from asking: <em>what parts of the problem can run at the same time without interfering?</em>
Think <strong>data</strong>, <strong>task</strong>, and <strong>pipeline</strong> parallelism.</p>
<hr>
<h1 id="1-how-to-recognize-parallelism">1) How to <em>recognize</em> parallelism</h1>
<p><strong>Patterns to look for</strong></p>
<ul>
<li><strong>Data parallelism</strong> — same operation applied independently to many items (map, filter, numeric loops).</li>
<li><strong>Task parallelism</strong> — different independent tasks that can run concurrently (download file A and process file B).</li>
<li><strong>Pipeline parallelism</strong> — a sequence of stages where different items can be at different stages simultaneously (producer → transform → persist).</li>
<li><strong>Embarrassingly parallel</strong> — tasks with no communication (ideal).</li>
<li><strong>Divide-and-conquer</strong> — split, solve subproblems, combine results.</li>
</ul>
<p><strong>Questions to ask</strong></p>
<ol>
<li>What are the independent units of work? (per item? per stage?)</li>
<li>Are there data dependencies between units? (true dependency — can’t run concurrently)</li>
<li>Which bottleneck is more important: CPU or I/O?</li>
<li>What’s the expected task granularity (ms, µs, seconds)?</li>
<li>How many cores and how much memory will be used?</li>
</ol>
<p><strong>Rules of thumb</strong></p>
<ul>
<li>If the workload is <strong>CPU-bound</strong> and you have many independent items → use CPU parallelism (Tasks, <code>Parallel.For</code>, PLINQ).</li>
<li>If the workload is <strong>IO-bound</strong> (network, disk) → use async/await and asynchronous I/O.</li>
<li>If you need ordered or staged processing → use pipeline constructs (Dataflow, Channels, BlockingCollection).</li>
<li>Avoid creating too many OS threads — prefer thread-pool / Tasks for most apps.</li>
</ul>
<hr>
<h1 id="2-trade-offs--theory-quick">2) Trade-offs &amp; theory (quick)</h1>
<p><strong>Amdahl’s Law</strong> — if fraction <code>P</code> is parallelizable and you have <code>N</code> workers, max speedup <code>S = 1 / ( (1-P) + P / N )</code>.</p>
<p>Example: <code>P = 0.8</code> (80% parallel), <code>N = 4</code> cores.
Compute step-by-step:</p>
<ul>
<li>Parallel portion per core = <code>P / N</code> = <code>0.8 / 4 = 0.2</code>.</li>
<li>Serial portion = <code>1 - P = 0.2</code>.</li>
<li>Sum = <code>0.2 + 0.2 = 0.4</code>.</li>
<li>Speedup S = <code>1 / 0.4 = 2.5</code>.</li>
</ul>
<p>So with 4 cores, you get 2.5×, not 4×.</p>
<p><strong>Overheads</strong>: thread creation, context switches, synchronization, memory bandwidth, false sharing. Measure.</p>
<hr>
<h1 id="3-when-to-choose-each-primitive">3) When to choose each primitive</h1>
<ul>
<li><strong>Manual <code>Thread</code></strong> — low-level control, thread affinity, set apartment states, long-lived background threads. Rarely needed.</li>
<li><strong>ThreadPool / <code>Task</code> / <code>Task.Run</code></strong> — general-purpose, use for both CPU and IO (but prefer async for IO). Default choice for concurrency in .NET.</li>
<li><strong><code>Parallel.For</code> / <code>Parallel.ForEach</code></strong> — easy data parallel loops for CPU-bound work.</li>
<li><strong>PLINQ (<code>AsParallel()</code>)</strong> — LINQ-friendly data parallelism.</li>
<li><strong><code>async/await</code> + <code>HttpClient</code> etc.</strong> — IO-bound concurrency; scales with many outstanding requests.</li>
<li><strong><code>BlockingCollection&lt;T&gt;</code> / <code>ConcurrentQueue&lt;T&gt;</code> &amp; consumer threads</strong> — producer-consumer.</li>
<li><strong>TPL Dataflow / System.Threading.Channels</strong> — structured pipelines, backpressure, buffering.</li>
<li><strong><code>Interlocked</code> / <code>Concurrent*</code> collections</strong> — fast atomic ops &amp; thread-safe collections.</li>
<li><strong>Locks (<code>lock</code>, <code>SemaphoreSlim</code>)</strong> — protect shared state; prefer fine-grained locking or lock-free if needed.</li>
</ul>
<hr>
<h1 id="4-practical-c-examples">4) Practical C# examples</h1>
<p>All examples are self-contained snippets. Use .NET 6+ or 7+.</p>
<hr>
<h2 id="a--low-level-thread-when-you-need-it">A — Low level: <code>Thread</code> (when you need it)</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading;

<span class="hljs-keyword">class</span> <span class="hljs-title">ThreadExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoWork</span>(<span class="hljs-params"><span class="hljs-keyword">object</span> id</span>)</span>
    {
        Console.WriteLine(<span class="hljs-string">$"Thread <span class="hljs-subst">{id}</span> started."</span>);
        Thread.Sleep(<span class="hljs-number">1000</span>);
        Console.WriteLine(<span class="hljs-string">$"Thread <span class="hljs-subst">{id}</span> finished."</span>);
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> t1 = <span class="hljs-keyword">new</span> Thread(DoWork);
        <span class="hljs-keyword">var</span> t2 = <span class="hljs-keyword">new</span> Thread(DoWork);

        t1.Start(<span class="hljs-number">1</span>);
        t2.Start(<span class="hljs-number">2</span>);

        t1.Join();
        t2.Join();

        Console.WriteLine(<span class="hljs-string">"Done."</span>);
    }
}
</div></code></pre>
<p><strong>When</strong>: you need a dedicated OS thread (rare). <strong>Downside</strong>: creation cost, no thread-pool integration.</p>
<hr>
<h2 id="b--preferred-task--taskrun-cpu-bound--cancellation">B — Preferred: <code>Task</code> + <code>Task.Run</code> (CPU-bound) &amp; cancellation</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">TaskExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Compute</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>
    {
        <span class="hljs-comment">// CPU-bound work</span>
        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) sum += i % <span class="hljs-number">7</span>;
        <span class="hljs-keyword">return</span> sum;
    }

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> cts = <span class="hljs-keyword">new</span> CancellationTokenSource();

        <span class="hljs-keyword">var</span> t = Task.Run(() =&gt; Compute(<span class="hljs-number">50</span>_000_000), cts.Token);

        <span class="hljs-comment">// optionally cancel:</span>
        <span class="hljs-comment">// cts.CancelAfter(TimeSpan.FromSeconds(2));</span>

        <span class="hljs-keyword">try</span>
        {
            <span class="hljs-keyword">int</span> result = <span class="hljs-keyword">await</span> t;
            Console.WriteLine(<span class="hljs-string">$"Result: <span class="hljs-subst">{result}</span>"</span>);
        }
        <span class="hljs-keyword">catch</span> (OperationCanceledException)
        {
            Console.WriteLine(<span class="hljs-string">"Cancelled"</span>);
        }
    }
}
</div></code></pre>
<p><strong>When</strong>: general CPU parallel tasks; use <code>Task</code> for composition, cancellation, exception handling.</p>
<hr>
<h2 id="c--data-parallelism-parallelfor-cpu-heavy-loop">C — Data parallelism: <code>Parallel.For</code> (CPU heavy loop)</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">ParallelForExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">int</span> n = <span class="hljs-number">20</span>_000_000;
        <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;

        Parallel.For(<span class="hljs-number">0</span>, n,
            () =&gt; <span class="hljs-number">0L</span>, <span class="hljs-comment">// local init</span>
            (i, state, local) =&gt;
            {
                local += i % <span class="hljs-number">3</span>;
                <span class="hljs-keyword">return</span> local;
            },
            local =&gt; Interlocked.Add(<span class="hljs-keyword">ref</span> total, local) <span class="hljs-comment">// local finally</span>
        );

        Console.WriteLine(<span class="hljs-string">$"Total: <span class="hljs-subst">{total}</span>"</span>);
    }
}
</div></code></pre>
<p><strong>When</strong>: CPU-bound loops, independent iterations. <code>Parallel.For</code> handles partitioning and uses thread-pool.</p>
<hr>
<h2 id="d--plinq-easy-linq-parallelism">D — PLINQ (easy LINQ parallelism)</h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Linq;

<span class="hljs-keyword">class</span> <span class="hljs-title">PlinqExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> numbers = Enumerable.Range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>_000_000);

        <span class="hljs-keyword">var</span> sum = numbers
            .AsParallel()
            .WithDegreeOfParallelism(Environment.ProcessorCount)
            .Where(x =&gt; (x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)
            .Select(x =&gt; x * <span class="hljs-number">2</span>)
            .Sum();

        Console.WriteLine(sum);
    }
}
</div></code></pre>
<p><strong>When</strong>: you already use LINQ and want parallel processing. Beware ordering and side-effects.</p>
<hr>
<h2 id="e--io-bound-concurrency-asyncawait-with-httpclient">E — IO-bound concurrency: <code>async/await</code> with <code>HttpClient</code></h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Net.Http;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">AsyncHttpExample</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> urls = <span class="hljs-keyword">new</span>[] {
            <span class="hljs-string">"https://example.com"</span>,
            <span class="hljs-string">"https://example.org"</span>,
            <span class="hljs-string">"https://example.net"</span>
        };

        <span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> http = <span class="hljs-keyword">new</span> HttpClient { Timeout = TimeSpan.FromSeconds(<span class="hljs-number">10</span>) };

        <span class="hljs-comment">// fire many requests concurrently, await all</span>
        <span class="hljs-keyword">var</span> tasks = urls.Select(u =&gt; http.GetStringAsync(u)).ToArray();

        <span class="hljs-keyword">string</span>[] contents = <span class="hljs-keyword">await</span> Task.WhenAll(tasks);

        Console.WriteLine(<span class="hljs-string">$"Fetched <span class="hljs-subst">{contents.Length}</span> pages."</span>);
    }
}
</div></code></pre>
<p><strong>When</strong>: many concurrent requests or high-latency I/O. <code>async</code> lets the thread do other work while waiting.</p>
<hr>
<h2 id="f--producer-consumer-blockingcollectiont">F — Producer-consumer: <code>BlockingCollection&lt;T&gt;</code></h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Collections.Concurrent;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">ProducerConsumer</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> bc = <span class="hljs-keyword">new</span> BlockingCollection&lt;<span class="hljs-keyword">int</span>&gt;(boundedCapacity: <span class="hljs-number">100</span>);

        <span class="hljs-comment">// Producer</span>
        <span class="hljs-keyword">var</span> prod = Task.Run(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)
            {
                bc.Add(i);
                <span class="hljs-comment">// simulate production latency</span>
                Thread.Sleep(<span class="hljs-number">1</span>);
            }
            bc.CompleteAdding();
        });

        <span class="hljs-comment">// Consumer(s)</span>
        <span class="hljs-keyword">var</span> consumers = Enumerable.Range(<span class="hljs-number">0</span>, Environment.ProcessorCount)
            .Select(id =&gt; Task.Run(() =&gt;
            {
                <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> bc.GetConsumingEnumerable())
                {
                    <span class="hljs-comment">// process item</span>
                }
            })).ToArray();

        Task.WaitAll(<span class="hljs-keyword">new</span>[] { prod }.Concat(consumers).ToArray());

        Console.WriteLine(<span class="hljs-string">"All done."</span>);
    }
}
</div></code></pre>
<p><strong>When</strong>: buffered handoff between producers and consumers. <code>BlockingCollection</code> provides thread-safe bounded buffers and built-in blocking.</p>
<hr>
<h2 id="g--pipeline--backpressure-tpl-dataflow-recommended-for-complex-pipelines">G — Pipeline / backpressure: TPL Dataflow (recommended for complex pipelines)</h2>
<p>You need to add <code>System.Threading.Tasks.Dataflow</code> (NuGet).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading.Tasks;
<span class="hljs-keyword">using</span> System.Threading.Tasks.Dataflow;

<span class="hljs-keyword">class</span> <span class="hljs-title">DataflowPipeline</span>
{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> downloadBlock = <span class="hljs-keyword">new</span> TransformBlock&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>&gt;(<span class="hljs-keyword">async</span> url =&gt;
        {
            <span class="hljs-comment">// simulate download</span>
            <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">100</span>);
            <span class="hljs-keyword">return</span> <span class="hljs-string">$"content-of-<span class="hljs-subst">{url}</span>"</span>;
        }, <span class="hljs-keyword">new</span> ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = <span class="hljs-number">4</span> });

        <span class="hljs-keyword">var</span> processBlock = <span class="hljs-keyword">new</span> TransformBlock&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">string</span>&gt;(content =&gt;
        {
            <span class="hljs-comment">// CPU-bound processing</span>
            <span class="hljs-keyword">return</span> content.ToUpperInvariant();
        }, <span class="hljs-keyword">new</span> ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = Environment.ProcessorCount });

        <span class="hljs-keyword">var</span> writeBlock = <span class="hljs-keyword">new</span> ActionBlock&lt;<span class="hljs-keyword">string</span>&gt;(res =&gt;
        {
            Console.WriteLine(<span class="hljs-string">$"Saved: <span class="hljs-subst">{res.Substring(<span class="hljs-number">0</span>, Math.Min(<span class="hljs-number">20</span>, res.Length))}</span>"</span>);
        }, <span class="hljs-keyword">new</span> ExecutionDataflowBlockOptions { MaxDegreeOfParallelism = <span class="hljs-number">2</span> });

        <span class="hljs-comment">// link with bounded capacity to provide backpressure</span>
        <span class="hljs-keyword">var</span> linkOptions = <span class="hljs-keyword">new</span> DataflowLinkOptions { PropagateCompletion = <span class="hljs-literal">true</span> };
        downloadBlock.LinkTo(processBlock, linkOptions);
        processBlock.LinkTo(writeBlock, linkOptions);

        <span class="hljs-comment">// Post work</span>
        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> url <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span>[] { <span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span> })
            downloadBlock.Post(url);

        downloadBlock.Complete();
        <span class="hljs-keyword">await</span> writeBlock.Completion;
        Console.WriteLine(<span class="hljs-string">"Pipeline finished."</span>);
    }
}
</div></code></pre>
<p><strong>When</strong>: multiple stages, need buffering and backpressure control, max-degree-of-parallelism per stage.</p>
<hr>
<h2 id="h--lock-free-atomic-ops-interlocked">H — Lock-free atomic ops: <code>Interlocked</code></h2>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;
<span class="hljs-keyword">using</span> System.Threading;
<span class="hljs-keyword">using</span> System.Threading.Tasks;

<span class="hljs-keyword">class</span> <span class="hljs-title">InterlockedExample</span>
{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> total = <span class="hljs-number">0</span>;

    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
    {
        <span class="hljs-keyword">var</span> tasks = Enumerable.Range(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>).Select(_ =&gt; Task.Run(() =&gt;
        {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>_000_000; i++)
                Interlocked.Add(<span class="hljs-keyword">ref</span> total, <span class="hljs-number">1</span>);
        })).ToArray();

        Task.WaitAll(tasks);
        Console.WriteLine(total); <span class="hljs-comment">// 8,000,000</span>
    }
}
</div></code></pre>
<p><strong>When</strong>: very fast atomic counters or compare-and-swap use cases.</p>
<hr>
<h1 id="5-common-concurrency-pitfalls--how-to-avoid-them">5) Common concurrency pitfalls &amp; how to avoid them</h1>
<ul>
<li><strong>Race conditions</strong> — protect shared mutable state (prefer immutable data or message passing).</li>
<li><strong>Deadlocks</strong> — avoid nested locks, use timeouts, prefer <code>SemaphoreSlim</code> with <code>WaitAsync</code>.</li>
<li><strong>False sharing</strong> — unrelated data on same cache line; pad hot fields if needed.</li>
<li><strong>Over-parallelization</strong> — too many tiny tasks increase overhead. Batch work.</li>
<li><strong>Contention</strong> — high lock contention kills scalability. Use partitioned state, lock-free or concurrent collections.</li>
<li><strong>Blocking in thread-pool threads</strong> — avoid blocking calls in the thread pool; use async I/O or <code>Task.Run</code> for blocking CPU work.</li>
<li><strong>Not measuring</strong> — use profiling (perf, dotnet-counters, BenchmarkDotNet) before optimizing.</li>
<li><strong>Ignoring cancellation</strong> — always accept <code>CancellationToken</code> for long-running tasks.</li>
</ul>
<hr>
<h1 id="6-practical-checklist-when-parallelizing-a-piece-of-code">6) Practical checklist when parallelizing a piece of code</h1>
<ol>
<li>Identify independent units (per item / per stage).</li>
<li>Classify as CPU-bound or IO-bound.</li>
<li>Choose primitive: <code>async</code> for IO, <code>Parallel</code>/<code>Task</code> for CPU, Dataflow/Channels for pipeline.</li>
<li>Estimate granularity and partition size (avoid tiny tasks).</li>
<li>Use thread-safe/lock-free collections; minimize shared state.</li>
<li>Add cancellation &amp; timeouts.</li>
<li>Measure with realistic load.</li>
<li>Review for race conditions and deadlocks.</li>
<li>Tune degree of parallelism (Environment.ProcessorCount is a good start).</li>
<li>Document assumptions.</li>
</ol>
<hr>
<h1 id="7-short-decision-table">7) Short decision table</h1>
<ul>
<li><strong>Many short HTTP requests</strong> → <code>async/await</code> + <code>HttpClient</code></li>
<li><strong>Large CPU loop over array/list</strong> → <code>Parallel.For</code> or <code>Partitioner</code> or PLINQ</li>
<li><strong>Independent tasks with varying durations</strong> → <code>Task.Run</code> + <code>Task.WhenAll</code></li>
<li><strong>Ordered pipeline with stages</strong> → TPL Dataflow or Channels</li>
<li><strong>Low-level control, thread pinning</strong> → <code>Thread</code> (rare)</li>
<li><strong>Producer-consumer</strong> → <code>BlockingCollection</code> or <code>Channels</code></li>
</ul>
<hr>
<h1 id="8-final-tips">8) Final tips</h1>
<ul>
<li>Default to <code>Task</code>/thread-pool + <code>async</code> where appropriate.</li>
<li>Prefer message passing and immutable data; keep shared mutable state small and well-protected.</li>
<li>Always profile — the biggest wins come from reducing contention and balancing work sizes.</li>
<li>Use <code>DegreeOfParallelism</code> limits and bounded buffers to avoid exhausting resources.</li>
</ul>
<hr>
<p><strong>NOTE:</strong> This page is generated with assistance from AI tools.</p>

</body>
</html>
