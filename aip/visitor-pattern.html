<!DOCTYPE html>
<html>
<head>
<title>The MSD Book :: Visitor Pattern</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="visitor-pattern--deep-dive-with-runnable-c-beforeafter-refactor">Visitor pattern — deep dive (with runnable C# before/after refactor)</h1>
<p>
    <img src="msd-book-front.png" 
    alt="The MSD Book" width="200" style="float: left; margin: 0 1rem 1rem 0;"/>
    Short summary: <strong>Visitor</strong> separates operations from the object structure they operate on. Use it when you have a fixed set of element types (an object graph) and you want to add many different operations over that graph without changing the element classes. It trades some coupling (elements must accept visitors) for easier extension of behavior and cleaner single-responsibility design.</p>
<p>Below: a small, ready-to-run C# example using an expression AST. First I show a <em>before</em> design where nodes implement operations (Evaluate, Print) themselves — this works but gets messy when you add more operations. Then an <em>after</em> refactor using the Visitor pattern: nodes only accept visitors; concrete visitors implement Evaluate / Print. Finally: a lint-style checklist and pitfalls.</p>
<hr>
<h1 id="before--nodes-own-operations-problematic-when-operations-multiply">Before — nodes own operations (problematic when operations multiply)</h1>
<p>Save this as <code>BeforeVisitor.cs</code> and run (<code>dotnet run</code> in a console app or compile as you like).</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">VisitorBefore</span>
{
    <span class="hljs-comment">// Expression AST</span>
    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Expr</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Evaluate</span>(<span class="hljs-params"></span>)</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">string</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span>;
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> : <span class="hljs-title">Expr</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Value { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span></span>)</span> =&gt; Value = <span class="hljs-keyword">value</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Evaluate</span>(<span class="hljs-params"></span>)</span> =&gt; Value;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span> =&gt; Value.ToString();
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Add</span> : <span class="hljs-title">Expr</span>
    {
        <span class="hljs-keyword">public</span> Expr Left { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">public</span> Expr Right { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Add</span>(<span class="hljs-params">Expr left, Expr right</span>)</span>
        {
            Left = left; Right = right;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Evaluate</span>(<span class="hljs-params"></span>)</span> =&gt; Left.Evaluate() + Right.Evaluate();
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span> =&gt; <span class="hljs-string">$"(<span class="hljs-subst">{Left.Print()}</span> + <span class="hljs-subst">{Right.Print()}</span>)"</span>;
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Mul</span> : <span class="hljs-title">Expr</span>
    {
        <span class="hljs-keyword">public</span> Expr Left { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">public</span> Expr Right { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mul</span>(<span class="hljs-params">Expr left, Expr right</span>)</span>
        {
            Left = left; Right = right;
        }

        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Evaluate</span>(<span class="hljs-params"></span>)</span> =&gt; Left.Evaluate() * Right.Evaluate();
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">string</span> <span class="hljs-title">Print</span>(<span class="hljs-params"></span>)</span> =&gt; <span class="hljs-string">$"(<span class="hljs-subst">{Left.Print()}</span> * <span class="hljs-subst">{Right.Print()}</span>)"</span>;
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
        {
            <span class="hljs-comment">// (1 + 2) * 3</span>
            Expr expr = <span class="hljs-keyword">new</span> Mul(<span class="hljs-keyword">new</span> Add(<span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Number(<span class="hljs-number">2</span>)), <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>));
            Console.WriteLine(<span class="hljs-string">"Print: "</span> + expr.Print());
            Console.WriteLine(<span class="hljs-string">"Eval: "</span> + expr.Evaluate());
        }
    }
}
</div></code></pre>
<p><strong>Problems with this approach</strong></p>
<ul>
<li>When you add a new operation (e.g., type-check, optimization, serialization), you must modify every node class to add that method.</li>
<li>Nodes accumulate many responsibilities (violates SRP).</li>
<li>If you need different outputs (string, JSON, pretty-print, evaluation with different semantics), duplication grows.</li>
</ul>
<hr>
<h1 id="after--visitor-refactor-clean-separation-of-operations">After — Visitor refactor (clean separation of operations)</h1>
<p>This refactor extracts operations into visitors. Nodes implement a single <code>Accept</code> method. Concrete visitors implement the operations. Save as <code>AfterVisitor.cs</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">using</span> System;

<span class="hljs-keyword">namespace</span> <span class="hljs-title">VisitorAfter</span>
{
    <span class="hljs-comment">// Element interface</span>
    <span class="hljs-keyword">interface</span> <span class="hljs-title">IExpr</span>
    {
        T Accept&lt;T&gt;(IExprVisitor&lt;T&gt; visitor);
    }

    <span class="hljs-comment">// Concrete element types</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title">Number</span> : <span class="hljs-title">IExpr</span>
    {
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> Value { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Number</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> v</span>)</span> =&gt; Value = v;
        <span class="hljs-keyword">public</span> T Accept&lt;T&gt;(IExprVisitor&lt;T&gt; visitor) =&gt; visitor.VisitNumber(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Add</span> : <span class="hljs-title">IExpr</span>
    {
        <span class="hljs-keyword">public</span> IExpr Left { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">public</span> IExpr Right { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Add</span>(<span class="hljs-params">IExpr l, IExpr r</span>)</span> { Left = l; Right = r; }
        <span class="hljs-keyword">public</span> T Accept&lt;T&gt;(IExprVisitor&lt;T&gt; visitor) =&gt; visitor.VisitAdd(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Mul</span> : <span class="hljs-title">IExpr</span>
    {
        <span class="hljs-keyword">public</span> IExpr Left { <span class="hljs-keyword">get</span>; }
        <span class="hljs-keyword">public</span> IExpr Right { <span class="hljs-keyword">get</span>; }
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mul</span>(<span class="hljs-params">IExpr l, IExpr r</span>)</span> { Left = l; Right = r; }
        <span class="hljs-keyword">public</span> T Accept&lt;T&gt;(IExprVisitor&lt;T&gt; visitor) =&gt; visitor.VisitMul(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">// Visitor interface (generic result type)</span>
    <span class="hljs-keyword">interface</span> <span class="hljs-title">IExprVisitor</span>&lt;<span class="hljs-title">T</span>&gt;
    {
        <span class="hljs-function">T <span class="hljs-title">VisitNumber</span>(<span class="hljs-params">Number n</span>)</span>;
        <span class="hljs-function">T <span class="hljs-title">VisitAdd</span>(<span class="hljs-params">Add a</span>)</span>;
        <span class="hljs-function">T <span class="hljs-title">VisitMul</span>(<span class="hljs-params">Mul m</span>)</span>;
    }

    <span class="hljs-comment">// Concrete visitor: evaluator</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title">EvalVisitor</span> : <span class="hljs-title">IExprVisitor</span>&lt;<span class="hljs-title">int</span>&gt;
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">VisitNumber</span>(<span class="hljs-params">Number n</span>)</span> =&gt; n.Value;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">VisitAdd</span>(<span class="hljs-params">Add a</span>)</span> =&gt; a.Left.Accept(<span class="hljs-keyword">this</span>) + a.Right.Accept(<span class="hljs-keyword">this</span>);
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">VisitMul</span>(<span class="hljs-params">Mul m</span>)</span> =&gt; m.Left.Accept(<span class="hljs-keyword">this</span>) * m.Right.Accept(<span class="hljs-keyword">this</span>);
    }

    <span class="hljs-comment">// Concrete visitor: pretty-printer</span>
    <span class="hljs-keyword">class</span> <span class="hljs-title">PrintVisitor</span> : <span class="hljs-title">IExprVisitor</span>&lt;<span class="hljs-title">string</span>&gt;
    {
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-title">VisitNumber</span>(<span class="hljs-params">Number n</span>)</span> =&gt; n.Value.ToString();
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-title">VisitAdd</span>(<span class="hljs-params">Add a</span>)</span> =&gt; <span class="hljs-string">$"(<span class="hljs-subst">{a.Left.Accept(<span class="hljs-keyword">this</span>)}</span> + <span class="hljs-subst">{a.Right.Accept(<span class="hljs-keyword">this</span>)}</span>)"</span>;
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">string</span> <span class="hljs-title">VisitMul</span>(<span class="hljs-params">Mul m</span>)</span> =&gt; <span class="hljs-string">$"(<span class="hljs-subst">{m.Left.Accept(<span class="hljs-keyword">this</span>)}</span> * <span class="hljs-subst">{m.Right.Accept(<span class="hljs-keyword">this</span>)}</span>)"</span>;
    }

    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>
    {
        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"></span>)</span>
        {
            <span class="hljs-comment">// (1 + 2) * 3</span>
            IExpr expr = <span class="hljs-keyword">new</span> Mul(<span class="hljs-keyword">new</span> Add(<span class="hljs-keyword">new</span> Number(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> Number(<span class="hljs-number">2</span>)), <span class="hljs-keyword">new</span> Number(<span class="hljs-number">3</span>));

            <span class="hljs-keyword">var</span> eval = <span class="hljs-keyword">new</span> EvalVisitor();
            <span class="hljs-keyword">var</span> printer = <span class="hljs-keyword">new</span> PrintVisitor();

            Console.WriteLine(<span class="hljs-string">"Print: "</span> + expr.Accept(printer));
            Console.WriteLine(<span class="hljs-string">"Eval: "</span> + expr.Accept(eval));
        }
    }
}
</div></code></pre>
<p><strong>Benefits</strong></p>
<ul>
<li>Adding a new operation means adding a new Visitor type — node classes remain unchanged.</li>
<li>Each visitor encapsulates a single concern (SRP).</li>
<li>You can keep different visitors that produce different result types by using a generic visitor interface.</li>
<li>Tests for operations are isolated to visitor implementations.</li>
</ul>
<hr>
<h1 id="when-to-use-visitor-guidelines">When to use Visitor (guidelines)</h1>
<p>Use Visitor when:</p>
<ul>
<li>The object graph (element types) is relatively stable (you know the classes and they won't change often).</li>
<li>You need to add many disparate operations over that graph (printing, evaluation, serialization, optimization, metrics).</li>
<li>You want to keep element classes focused on data/structure and move algorithmic behavior into visitors.</li>
</ul>
<p>Avoid Visitor when:</p>
<ul>
<li>You expect to add many new element types often — Visitor requires modifying the visitor interface and all its implementations whenever you add a new element.</li>
<li>The element API must remain closed to external visitors for encapsulation/security reasons.</li>
</ul>
<hr>
<h1 id="variations--practical-notes">Variations &amp; practical notes</h1>
<ul>
<li><strong>Double-dispatch vs generic visitor</strong>: I used <code>Accept&lt;T&gt;(IExprVisitor&lt;T&gt;)</code> with a generic return type for convenience. Some projects use a non-generic <code>IVisitor</code> with <code>void Visit(X x)</code> and visitor holds internal state (e.g., push/pop stack). Use whichever fits your type/return needs.</li>
<li><strong>Default behavior</strong>: For large element sets, provide an abstract base visitor with default implementations so adding a new element type doesn't break all concrete visitors immediately.</li>
<li><strong>Extensibility</strong>: If you need both new elements and new operations frequently, Visitor may not be the right pattern—consider composition, strategy, or simpler polymorphism.</li>
</ul>
<hr>
<h1 id="ready-to-run-usage-snippet-after-version">Ready-to-run usage snippet (After version)</h1>
<p>If you compile the AfterVisitor code and run, you'll see:</p>
<pre class="hljs"><code><div>Print: ((1 + 2) * 3)
Eval: 9
</div></code></pre>
<hr>
<h1 id="lint-style-checklist-for-code-reviews">Lint-style checklist (for code reviews)</h1>
<ul>
<li>
<p>Elements</p>
<ul>
<li><input type="checkbox" id="checkbox0"><label for="checkbox0">Each concrete element implements </label><code>Accept</code> and only <code>Accept</code> (no unrelated operations).</li>
<li><input type="checkbox" id="checkbox1"><label for="checkbox1">Element classes expose only necessary structural data (avoid behavior creep).</label></li>
</ul>
</li>
<li>
<p>Visitor API</p>
<ul>
<li><input type="checkbox" id="checkbox2"><label for="checkbox2">The visitor interface defines a </label><code>VisitX</code> method for each element type (names consistent and predictable).</li>
<li><input type="checkbox" id="checkbox3"><label for="checkbox3">Consider making the visitor interface generic if visitors return different types.</label></li>
<li><input type="checkbox" id="checkbox4"><label for="checkbox4">If visitor evolves, add a base/adapter visitor with default implementations to avoid breaking many concrete visitors.</label></li>
</ul>
</li>
<li>
<p>Implementation</p>
<ul>
<li><input type="checkbox" id="checkbox5"><label for="checkbox5">Visitor implementations are stateless where possible; if stateful, state is well-contained and documented.</label></li>
<li><input type="checkbox" id="checkbox6"><label for="checkbox6">Avoid long </label><code>switch</code>/<code>if</code> chains in visitors; rely on double-dispatch via <code>Accept</code>.</li>
<li><input type="checkbox" id="checkbox7"><label for="checkbox7">For cross-cutting visitors (e.g., optimization + evaluation), separate responsibilities into separate visitor classes.</label></li>
</ul>
</li>
<li>
<p>Tests</p>
<ul>
<li><input type="checkbox" id="checkbox8"><label for="checkbox8">Tests cover each visitor independently (unit-test behavior per operation).</label></li>
<li><input type="checkbox" id="checkbox9"><label for="checkbox9">Tests cover mixed graphs (composed elements) to exercise recursion and order.</label></li>
</ul>
</li>
<li>
<p>Performance &amp; safety</p>
<ul>
<li><input type="checkbox" id="checkbox10"><label for="checkbox10">Visitors avoid unnecessary allocations in hot paths (be mindful of string concatenation in pretty printers).</label></li>
<li><input type="checkbox" id="checkbox11"><label for="checkbox11">If visitors have internal stacks, ensure they are bounded or use iterative approaches if recursion depth is a concern.</label></li>
</ul>
</li>
</ul>
<hr>
<h1 id="common-pitfalls--how-to-avoid-them">Common pitfalls &amp; how to avoid them</h1>
<ol>
<li>
<p><strong>Wrong trade for mutability</strong>
Visitor is great for read-only operations. If visitors need to mutate internal private state of elements, you'll either need mutator APIs or break encapsulation. Avoid exposing internals; instead provide element-level operations that accept specific visitor intentions (or rethink pattern).</p>
</li>
<li>
<p><strong>Frequent element changes</strong>
If you add new element types often, Visitor forces edits across all visitors. Mitigation: provide a default base visitor with noop implementations so new methods don't break existing visitors; or choose a different pattern.</p>
</li>
<li>
<p><strong>Explosion of visitor classes</strong>
Having too many tiny visitors can complicate management. Group related operations into single visitors where it makes sense.</p>
</li>
<li>
<p><strong>Stateful visitor pitfalls</strong>
Visitors that keep complex state (e.g., caches, stacks) can be hard to reason about and not thread-safe. Prefer stateless visitors or explicitly document/limit reuse.</p>
</li>
<li>
<p><strong>Deep recursion / stack overflow</strong>
ASTs or graphs with deep nesting can cause recursion issues. Consider iterative traversal or tail-recursive optimization if applicable.</p>
</li>
<li>
<p><strong>Circular graphs</strong>
Visitor pattern is straightforward for trees. For graphs with cycles, you must add visited-node tracking to avoid infinite loops.</p>
</li>
</ol>
<hr>
<h1 id="short-checklist-for-deciding-to-use-visitor-in-a-design">Short checklist for deciding to use Visitor in a design</h1>
<ul>
<li>Is the set of element types stable? → <strong>Yes</strong> (good)</li>
<li>Are operations going to grow/variate significantly over time? → <strong>Yes</strong> (good)</li>
<li>Do you require direct access to private internals of elements? → <strong>Yes</strong> (bad — rethink)</li>
<li>Is the data structure a DAG/tree rather than arbitrary cyclic graph? → <strong>Preferable</strong></li>
</ul>
<p>If you answered <strong>Yes, Yes, No, Yes</strong> then Visitor is likely a good fit.</p>
<hr>
<p><strong>NOTE:</strong> This page is generated with assistance from AI tools.</p>

</body>
</html>
